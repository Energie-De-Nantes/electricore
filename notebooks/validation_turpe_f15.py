import marimo

__generated_with = "0.16.0"
app = marimo.App(width="medium")

with app.setup:
    import marimo as mo
    import polars as pl
    import pandas as pd
    import sys
    from pathlib import Path
    from datetime import datetime, timezone
    import time
    from typing import Dict, List, Optional, Tuple

    # Ajouter le chemin du projet
    project_root = Path.cwd()
    if str(project_root) not in sys.path:
        sys.path.append(str(project_root))

    # Imports des loaders DuckDB
    from electricore.core.loaders.duckdb_loader import f15, c15, r151, execute_custom_query

    # Imports des pipelines Polars
    from electricore.core.pipelines_polars.energie_polars import (
        pipeline_energie_polars,
        calculer_periodes_energie_polars
    )
    from electricore.core.pipelines_polars.abonnements_polars import (
        pipeline_abonnements,
        calculer_periodes_abonnement
    )
    from electricore.core.pipelines_polars.turpe_polars import (
        load_turpe_rules_polars,
        ajouter_turpe_fixe,
        ajouter_turpe_variable
    )
    from electricore.core.pipelines_polars.perimetre_polars import (
        detecter_points_de_rupture,
        inserer_evenements_facturation
    )

    # Import connecteur Odoo
    from electricore.etl.connectors.odoo import OdooReader


@app.cell(hide_code=True)
def _():
    """Configuration Odoo depuis secrets.toml"""
    import tomllib

    # Chercher le fichier secrets.toml
    secrets_paths = [
        Path.cwd() / '.dlt' / 'secrets.toml',
        Path.cwd() / 'electricore' / 'etl' / '.dlt' / 'secrets.toml'
    ]

    config = {}
    secrets_file_found = None

    for secrets_path in secrets_paths:
        if secrets_path.exists():
            with open(secrets_path, 'rb') as f:
                config_data = tomllib.load(f)
                config = config_data.get('odoo', {})
                secrets_file_found = secrets_path
            break

    if not config:
        _msg = mo.md("""
        ‚ö†Ô∏è **Configuration Odoo non trouv√©e**

        Cr√©ez le fichier `.dlt/secrets.toml` ou `electricore/etl/.dlt/secrets.toml` avec :
        ```toml
        [odoo]
        url = "https://votre-instance.odoo.com"
        db = "votre_database"
        username = "votre_username"
        password = "votre_password"
        ```
        """)
    else:
        _msg = mo.md(f"""
        **Configuration charg√©e depuis**: `{secrets_file_found}`

        - URL: `{config.get('url', 'NON CONFIGUR√â')}`
        - Base: `{config.get('db', 'NON CONFIGUR√â')}`
        - Utilisateur: `{config.get('username', 'NON CONFIGUR√â')}`
        - Mot de passe: `{'***' if config.get('password') else 'NON CONFIGUR√â'}`
        """)
    _msg
    return (config,)


@app.cell
def _():
    mo.md(
        r"""
    # Validation du calcul TURPE avec les donn√©es F15

    Ce notebook compare les montants TURPE calcul√©s par le pipeline ElectriCore
    avec les donn√©es de facturation F15 d'Enedis.

    **Objectifs :**

    - ‚úÖ Validation multi-√©chelle (global, PDL, temporel)
    - ‚úÖ Identification des √©carts et leurs causes
    - ‚úÖ Gestion des diff√©rences attendues (compteurs non-intelligents, relev√©s manquants)
    - ‚úÖ Rapport de synth√®se interactif
    """
    )
    return


@app.cell
def _():
    mo.md(r"""# Pr√©paration""")
    return


@app.cell
def _():
    mo.md(r"""## Chargement des donn√©es F15""")
    return


@app.cell(hide_code=True)
def load_f15_data():
    """Extraction et agr√©gation des donn√©es TURPE depuis F15"""

    mo.md("## üìä Extraction des donn√©es F15 (TURPE factur√©)")

    print("üîÑ Chargement des donn√©es F15...")
    _start_time_f15 = time.time()

    # Requ√™te pour extraire les composantes TURPE depuis F15
    query_f15_turpe = """
    SELECT
        pdl,
        date_facture,
        date_debut,
        date_fin,
        libelle_ev,
        CASE
            WHEN libelle_ev LIKE '%Composante Gestion%' THEN 'Composante Gestion'
            WHEN libelle_ev LIKE '%Composante Comptage%' THEN 'Composante Comptage'
            WHEN libelle_ev LIKE '%Composante Soutirage%' THEN 'Composante Soutirage'
            WHEN libelle_ev LIKE '%Composante de relev√©%' THEN 'Composante Relev√©'
            WHEN libelle_ev LIKE '%Correctif%' THEN 'Correctif'
            ELSE 'Autres prestations'
        END as type_composante,
        CASE
            -- Priorit√© aux mentions explicites de "Part fixe" ou "Part variable"
            WHEN libelle_ev LIKE '%Part fixe%' THEN 'Fixe'
            WHEN libelle_ev LIKE '%Part variable%' THEN 'Variable'
            -- Puis classification par composante pour les cas non explicites
            WHEN libelle_ev LIKE '%Composante Gestion%' THEN 'Fixe'
            WHEN libelle_ev LIKE '%Composante Comptage%' THEN 'Fixe'
            WHEN libelle_ev LIKE '%Composante Soutirage%' THEN 'Variable'
            WHEN libelle_ev LIKE '%Composante de relev√©%' THEN 'Fixe'
            ELSE 'Autre'
        END as part_turpe,
        CAST(montant_ht AS DOUBLE) as montant_ht,
        CAST(quantite AS DOUBLE) as quantite,
        CAST(prix_unitaire AS DOUBLE) as prix_unitaire,
        unite,
        formule_tarifaire_acheminement
    FROM flux_enedis.flux_f15_detail
    WHERE nature_ev = '01'
    AND montant_ht IS NOT NULL
    """

    # Ex√©cuter la requ√™te
    lf_f15_turpe = execute_custom_query(query_f15_turpe, lazy=True)
    df_f15_turpe = lf_f15_turpe.collect()

    # Statistiques de base
    _load_time_f15 = time.time() - _start_time_f15
    _total_montant = df_f15_turpe.select(pl.col("montant_ht").sum()).item()
    _nb_pdl_uniques = df_f15_turpe.select(pl.col("pdl").n_unique()).item()
    _date_min = df_f15_turpe.select(pl.col("date_debut").min()).item()
    _date_max = df_f15_turpe.select(pl.col("date_fin").max()).item()

    print(f"‚úÖ Donn√©es F15 charg√©es en {_load_time_f15:.1f}s")
    print(f"üìä {len(df_f15_turpe):,} lignes de facturation TURPE")
    print(f"üí∞ Montant total TURPE F15: {_total_montant:,.2f} ‚Ç¨")
    print(f"üè† {_nb_pdl_uniques} PDL uniques")
    print(f"üìÖ P√©riode: {_date_min} ‚Üí {_date_max}")
    df_f15_turpe
    return (df_f15_turpe,)


@app.cell(hide_code=True)
def aggregations_f15(df_f15_turpe):
    """Agr√©gations des donn√©es F15 pour comparaison"""

    mo.md("### Agr√©gations F15")

    # Agr√©gation par PDL
    df_f15_par_pdl = (
        df_f15_turpe
        .group_by("pdl")
        .agg([
            pl.col("montant_ht").sum().alias("montant_total_f15"),
            pl.col("date_debut").min().alias("premiere_periode"),
            pl.col("date_fin").max().alias("derniere_periode"),
            pl.col("type_composante").n_unique().alias("nb_composantes")
        ])
        .sort("montant_total_f15", descending=True)
    )

    # Agr√©gation par mois
    df_f15_par_mois = (
        df_f15_turpe
        .with_columns([
            # Convertir en timezone naive pour √©viter les conflits de join
            pl.col("date_debut").str.to_datetime().dt.truncate("1mo").dt.replace_time_zone(None).alias("mois")
        ])
        .group_by("mois")
        .agg([
            pl.col("montant_ht").sum().alias("montant_f15"),
            pl.col("pdl").n_unique().alias("nb_pdl"),
            pl.len().alias("nb_lignes")
        ])
        .sort("mois")
    )

    # Agr√©gation par type de composante
    df_f15_par_composante = (
        df_f15_turpe
        .group_by(["type_composante", "part_turpe"])
        .agg([
            pl.col("montant_ht").sum().alias("montant_f15"),
            pl.len().alias("nb_lignes")
        ])
        .sort("montant_f15", descending=True)
    )
    return df_f15_par_composante, df_f15_par_mois, df_f15_par_pdl


@app.cell(hide_code=True)
def show_f15_summary(df_f15_par_composante, df_f15_par_mois, df_f15_par_pdl):
    """Affichage des r√©sum√©s F15"""
    mo.accordion(items={
        'f15 par pdl':df_f15_par_pdl,
        'f15 par mois':df_f15_par_mois,
        'f15 par composante':df_f15_par_composante,
    })
    return


@app.cell(hide_code=True)
def _():
    mo.md(r"""## S√©paration turpe fixe/variable""")
    return


@app.cell
def _(df_f15_turpe):
    # Extraction du TURPE fixe depuis F15
    _df_f15_fixe = (
        df_f15_turpe
        .filter(pl.col("part_turpe") == "Fixe")
        # .group_by("pdl")
        # .agg([
        #     pl.col("montant_ht").sum().alias("turpe_fixe_f15")
        # ])
    )

    # Statistiques de base
    _total_montant = _df_f15_fixe.select(pl.col("montant_ht").sum()).item()
    _nb_pdl_uniques = _df_f15_fixe.select(pl.col("pdl").n_unique()).item()
    _date_min = _df_f15_fixe.select(pl.col("date_debut").min()).item()
    _date_max = _df_f15_fixe.select(pl.col("date_fin").max()).item()

    print(f"‚úÖ Donn√©es F15 turpe fixe")
    print(f"üìä {len(_df_f15_fixe):,} lignes de facturation TURPE")
    print(f"üí∞ Montant total TURPE F15: {_total_montant:,.2f} ‚Ç¨")
    print(f"üè† {_nb_pdl_uniques} PDL uniques")
    print(f"üìÖ P√©riode: {_date_min} ‚Üí {_date_max}")
    _df_f15_fixe
    return


@app.cell
def _(df_f15_turpe):
    # Extraction du TURPE var depuis F15
    df_f15_variable = (
        df_f15_turpe
        .filter(pl.col("part_turpe") == "Variable")
        # .group_by("pdl")
        # .agg([
        #     pl.col("montant_ht").sum().alias("turpe_variable_f15")
        # ])
    )
    # Statistiques de base
    _total_montant = df_f15_variable.select(pl.col("montant_ht").sum()).item()
    _nb_pdl_uniques = df_f15_variable.select(pl.col("pdl").n_unique()).item()
    _date_min = df_f15_variable.select(pl.col("date_debut").min()).item()
    _date_max = df_f15_variable.select(pl.col("date_fin").max()).item()

    print(f"‚úÖ Donn√©es F15 turpe fixe")
    print(f"üìä {len(df_f15_variable):,} lignes de facturation TURPE")
    print(f"üí∞ Montant total TURPE F15: {_total_montant:,.2f} ‚Ç¨")
    print(f"üè† {_nb_pdl_uniques} PDL uniques")
    print(f"üìÖ P√©riode: {_date_min} ‚Üí {_date_max}")
    df_f15_variable
    return (df_f15_variable,)


@app.cell
def _():
    mo.md(r"""## R√©cup√©ration des pdl EDN""")
    return


@app.cell(hide_code=True)
def load_odoo_perimeter(config):
    """R√©cup√©ration du p√©rim√®tre de PDL depuis Odoo"""

    mo.md("## üè¢ R√©cup√©ration du p√©rim√®tre PDL (Odoo)")

    # Configuration Odoo (√† adapter selon votre configuration)
    try:
        print("üîÑ Connexion √† Odoo...")
        with OdooReader(config=config) as odoo:
            # R√©cup√©ration des PDL depuis les commandes Odoo, focus sur C5
            df_pdl_odoo = (
                odoo.query('sale.order',
                    domain=[('x_pdl', '!=', False)],  # Uniquement les commandes avec PDL
                    fields=['name', 'x_pdl', 'partner_id'])
                .filter(pl.col('x_pdl').is_not_null())
                .select([
                    pl.col('x_pdl').str.strip_chars().alias('pdl'),
                    pl.col('name').alias('order_name')
                ])
                .collect()
                .unique('pdl')
            )

        nb_pdl_odoo = len(df_pdl_odoo)
        print(f"‚úÖ {nb_pdl_odoo} PDL r√©cup√©r√©s depuis Odoo")

        # Aper√ßu des PDL
        if nb_pdl_odoo > 0:
            print(f"üìä Exemples PDL: {df_pdl_odoo.select('pdl').to_series().to_list()}")

        df_pdl_odoo = df_pdl_odoo

    except Exception as e:
        print(f"‚ö†Ô∏è Erreur connexion Odoo: {e}")
        print("üìÑ Continuons sans filtre Odoo (tous les PDL F15 seront analys√©s)")

        # DataFrame vide si pas de connexion Odoo
        df_pdl_odoo = pl.DataFrame({'pdl': [], 'order_name': []}, schema={'pdl': pl.Utf8, 'order_name': pl.Utf8})
    return (df_pdl_odoo,)


@app.cell
def _():
    mo.md(r"""## Chargement des flux pour pipeline""")
    return


@app.cell(hide_code=True)
def load_pipeline_data():
    """Chargement des donn√©es pour le pipeline de calcul TURPE"""

    mo.md("## üîß Calcul TURPE via le pipeline")

    print("üîÑ Chargement des donn√©es pour le pipeline...")
    _start_time_pipeline = time.time()

    # Charger l'historique C15 enrichi
    print("üìÑ Chargement historique C15...")
    lf_historique = c15().lazy()
    lf_historique_enrichi = inserer_evenements_facturation(
        detecter_points_de_rupture(lf_historique)
    )
    df_historique = lf_historique_enrichi.collect()

    # Charger les relev√©s R151
    print("üìÑ Chargement relev√©s R151...")
    lf_releves = r151().lazy()
    df_releves = lf_releves.collect()

    # Charger les r√®gles TURPE
    print("üìÑ Chargement r√®gles TURPE...")
    lf_regles_turpe = load_turpe_rules_polars()
    df_regles_turpe = lf_regles_turpe.collect()

    _load_time_pipeline = time.time() - _start_time_pipeline

    print(f"‚úÖ Donn√©es pipeline charg√©es en {_load_time_pipeline:.1f}s")
    print(f"üìä Historique C15: {len(df_historique)} √©v√©nements")
    print(f"üìä Relev√©s R151: {len(df_releves)} relev√©s")
    print(f"üìä R√®gles TURPE: {len(df_regles_turpe)} r√®gles tarifaires")
    return df_historique, df_releves


@app.cell
def _():
    mo.md(r"""# Analyse fiabilit√© calcul turpe fixe""")
    return


@app.cell
def _():
    mo.md(r"""## Calcul turpe fixe""")
    return


@app.cell(hide_code=True)
def calculate_turpe_fixe(df_historique):
    """Calcul TURPE fixe uniquement (abonnements)"""

    mo.md("## üè† Calcul TURPE Fixe (Abonnements)")

    print("üîÑ Calcul des p√©riodes d'abonnement...")
    _start_time_fixe = time.time()

    # Pipeline abonnements complet (inclut calcul + TURPE fixe)
    lf_periodes_abonnement = pipeline_abonnements(pl.LazyFrame(df_historique))
    df_periodes_abonnement = lf_periodes_abonnement.collect()

    # Agr√©gation du TURPE fixe par PDL
    df_turpe_fixe_pdl = (
        df_periodes_abonnement
        .group_by("pdl")
        .agg([
            pl.col("turpe_fixe").sum().alias("turpe_fixe_total"),
            pl.col("debut").min().alias("date_debut_periode"),
            pl.col("fin").max().alias("date_fin_periode")
        ])
    )

    calc_time_fixe = time.time() - _start_time_fixe

    # Statistiques TURPE fixe
    total_turpe_fixe = df_turpe_fixe_pdl.select(pl.col("turpe_fixe_total").sum()).item()
    nb_pdl_fixe = df_turpe_fixe_pdl.select(pl.col("pdl").n_unique()).item()

    print(f"‚úÖ Pipeline TURPE fixe ex√©cut√© en {calc_time_fixe:.1f}s")
    print(f"üí∞ Montant total TURPE fixe calcul√©: {total_turpe_fixe:,.2f} ‚Ç¨")
    print(f"üè† {nb_pdl_fixe} PDL trait√©s")
    return (df_turpe_fixe_pdl,)


@app.cell
def _():
    mo.md(r"""## Comparaison F15 vs Calcul√© - TURPE Fixe""")
    return


@app.cell(hide_code=True)
def compare_turpe_fixe(df_f15_turpe, df_turpe_fixe_pdl):
    """Comparaison d√©taill√©e F15 vs Pipeline pour le TURPE fixe"""

    print("üîç Comparaison F15 vs Pipeline pour TURPE fixe...")

    # Agr√©gation du TURPE fixe F15 par PDL
    df_f15_fixe_par_pdl = (
        df_f15_turpe
        .filter(pl.col("part_turpe") == "Fixe")
        .group_by("pdl")
        .agg([
            pl.col("montant_ht").sum().alias("turpe_fixe_f15"),
            pl.col("date_debut").min().alias("premiere_periode_f15"),
            pl.col("date_fin").max().alias("derniere_periode_f15"),
            pl.len().alias("nb_lignes_f15")
        ])
    )

    # Jointure compl√®te F15 vs Calcul√©
    df_comparison_fixe = (
        df_f15_fixe_par_pdl
        .join(df_turpe_fixe_pdl, on="pdl", how="full")
        .with_columns([
            pl.col("turpe_fixe_f15").fill_null(0.0),
            pl.col("turpe_fixe_total").fill_null(0.0)
        ])
        .with_columns([
            (pl.col("turpe_fixe_total") - pl.col("turpe_fixe_f15")).alias("ecart_absolu"),
            pl.when(pl.col("turpe_fixe_f15") != 0.0)
            .then(((pl.col("turpe_fixe_total") - pl.col("turpe_fixe_f15")) / pl.col("turpe_fixe_f15") * 100))
            .otherwise(pl.lit(None))
            .alias("ecart_relatif_pct"),
            # Classification des PDL
            pl.when((pl.col("turpe_fixe_f15") > 0) & (pl.col("turpe_fixe_total") > 0))
            .then(pl.lit("Pr√©sent des 2 c√¥t√©s"))
            .when((pl.col("turpe_fixe_f15") > 0) & (pl.col("turpe_fixe_total") == 0))
            .then(pl.lit("Manquant c√¥t√© calcul"))
            .when((pl.col("turpe_fixe_f15") == 0) & (pl.col("turpe_fixe_total") > 0))
            .then(pl.lit("En trop c√¥t√© calcul"))
            .otherwise(pl.lit("Vide des 2 c√¥t√©s"))
            .alias("statut_pdl")
        ])
        .sort(pl.col("ecart_absolu").abs(), descending=True)
    )

    # Statistiques globales
    total_f15_fixe = df_comparison_fixe.select(pl.col("turpe_fixe_f15").sum()).item()
    total_calcule_fixe = df_comparison_fixe.select(pl.col("turpe_fixe_total").sum()).item()
    ecart_global_fixe = total_calcule_fixe - total_f15_fixe
    _ecart_global_pct = (ecart_global_fixe / total_f15_fixe) * 100 if total_f15_fixe > 0 else 0

    nb_pdl_f15 = df_comparison_fixe.filter(pl.col("turpe_fixe_f15") > 0).select(pl.len()).item()
    nb_pdl_calcule = df_comparison_fixe.filter(pl.col("turpe_fixe_total") > 0).select(pl.len()).item()
    nb_pdl_communs = df_comparison_fixe.filter(
        (pl.col("turpe_fixe_f15") > 0) & (pl.col("turpe_fixe_total") > 0)
    ).select(pl.len()).item()

    taux_couverture = (nb_pdl_calcule / nb_pdl_f15) * 100 if nb_pdl_f15 > 0 else 0

    print(f"üìä R√âSULTATS COMPARAISON TURPE FIXE:")
    print(f"   üí∞ F15 fixe: {total_f15_fixe:,.2f} ‚Ç¨ ({nb_pdl_f15} PDL)")
    print(f"   üí∞ Calcul√© fixe: {total_calcule_fixe:,.2f} ‚Ç¨ ({nb_pdl_calcule} PDL)")
    print(f"   ‚öñÔ∏è √âcart global: {ecart_global_fixe:+,.2f} ‚Ç¨ ({_ecart_global_pct:+.1f}%)")
    print(f"   üéØ Couverture: {nb_pdl_communs}/{nb_pdl_f15} PDL ({taux_couverture:.1f}%)")

    return df_comparison_fixe, total_f15_fixe, total_calcule_fixe, ecart_global_fixe


@app.cell(hide_code=True)
def analyze_turpe_fixe_gaps(df_comparison_fixe):
    """Analyse des √©carts TURPE fixe par cat√©gorie"""

    print("\nüîç ANALYSE DES √âCARTS PAR CAT√âGORIE:")

    # Statistiques par statut PDL
    stats_par_statut = (
        df_comparison_fixe
        .group_by("statut_pdl")
        .agg([
            pl.len().alias("nb_pdl"),
            pl.col("turpe_fixe_f15").sum().alias("montant_f15"),
            pl.col("turpe_fixe_total").sum().alias("montant_calcule"),
            pl.col("ecart_absolu").sum().alias("ecart_total")
        ])
        .sort("ecart_total", descending=True)
    )

    for row in stats_par_statut.iter_rows(named=True):
        statut = row['statut_pdl']
        nb_pdl = row['nb_pdl']
        montant_f15 = row['montant_f15']
        montant_calcule = row['montant_calcule']
        ecart = row['ecart_total']

        print(f"   üìã {statut}: {nb_pdl} PDL")
        print(f"      F15: {montant_f15:,.2f} ‚Ç¨ | Calcul√©: {montant_calcule:,.2f} ‚Ç¨ | √âcart: {ecart:+,.2f} ‚Ç¨")

    # Top 10 des √©carts les plus importants (PDL communs seulement)
    top_ecarts = (
        df_comparison_fixe
        .filter(pl.col("statut_pdl") == "Pr√©sent des 2 c√¥t√©s")
        .filter(pl.col("ecart_relatif_pct").abs() > 0.1)  # √âcarts > 0.1%
        .head(10)
        .select([
            "pdl", "turpe_fixe_f15", "turpe_fixe_total",
            "ecart_absolu", "ecart_relatif_pct"
        ])
    )

    print(f"\nüìà TOP 10 √âCARTS SIGNIFICATIFS (PDL communs):")
    if len(top_ecarts) > 0:
        print(top_ecarts.to_pandas().to_string(index=False))
    else:
        print("   ‚úÖ Aucun √©cart significatif d√©tect√©!")

    return stats_par_statut, top_ecarts


@app.cell(hide_code=True)
def funnel_analysis_turpe_fixe(df_f15_turpe, df_turpe_fixe_pdl, df_pdl_odoo):
    """Analyse en entonnoir pour attribuer les √©carts du TURPE fixe"""

    print("\nüìä ANALYSE EN ENTONNOIR - TURPE FIXE")

    # √âtape 1: Montant F15 global fixe
    _df_f15_fixe_entonnoir = df_f15_turpe.filter(pl.col("part_turpe") == "Fixe")
    montant_f15_global = _df_f15_fixe_entonnoir.select(pl.col("montant_ht").sum()).item()
    nb_pdl_f15_global = _df_f15_fixe_entonnoir.select(pl.col("pdl").n_unique()).item()

    # √âtape 2: Filtrage segment C5 uniquement
    df_f15_c5 = _df_f15_fixe_entonnoir.filter(
        (pl.col("formule_tarifaire_acheminement").str.contains("C5")) |
        (pl.col("formule_tarifaire_acheminement").str.contains("CU"))
    )
    montant_f15_c5 = df_f15_c5.select(pl.col("montant_ht").sum()).item()
    nb_pdl_c5 = df_f15_c5.select(pl.col("pdl").n_unique()).item()
    ecart_hors_c5 = montant_f15_global - montant_f15_c5

    # √âtape 3: Filtrage temporel (exclure facturation √† √©choir)
    # Date de coupure = fin du mois dernier r√©volu
    from datetime import date
    import calendar
    _today = date.today()
    if _today.month == 1:
        _date_coupure = date(_today.year - 1, 12, 31)
    else:
        # Dernier jour du mois pr√©c√©dent
        _prev_month = _today.month - 1
        _prev_year = _today.year
        _last_day = calendar.monthrange(_prev_year, _prev_month)[1]
        _date_coupure = date(_prev_year, _prev_month, _last_day)

    df_f15_c5_temporel = df_f15_c5.filter(
        pl.col("date_fin").str.to_date() <= pl.date(_date_coupure.year, _date_coupure.month, _date_coupure.day)
    )
    montant_f15_c5_temporel = df_f15_c5_temporel.select(pl.col("montant_ht").sum()).item()
    nb_pdl_c5_temporel = df_f15_c5_temporel.select(pl.col("pdl").n_unique()).item()
    ecart_a_echoir = montant_f15_c5 - montant_f15_c5_temporel

    # √âtape 4: Filtrage p√©rim√®tre EDN (si donn√©es Odoo disponibles)
    if len(df_pdl_odoo) > 0:
        pdl_perimetre = df_pdl_odoo.select("pdl").to_series().to_list()
        df_f15_perimetre = df_f15_c5_temporel.filter(
            pl.col("pdl").is_in(pdl_perimetre)
        )
        _montant_f15_perimetre = df_f15_perimetre.select(pl.col("montant_ht").sum()).item()
        _nb_pdl_perimetre = df_f15_perimetre.select(pl.col("pdl").n_unique()).item()
        ecart_hors_perimetre = montant_f15_c5_temporel - _montant_f15_perimetre
        df_f15_final = df_f15_perimetre
    else:
        _montant_f15_perimetre = montant_f15_c5_temporel
        _nb_pdl_perimetre = nb_pdl_c5_temporel
        ecart_hors_perimetre = 0
        df_f15_final = df_f15_c5_temporel

    # √âtape 5: Comparaison avec le calcul√© (PDL pr√©sents des deux c√¥t√©s)
    # Agr√©gation F15 par PDL pour la comparaison finale
    df_f15_final_par_pdl = df_f15_final.group_by("pdl").agg([
        pl.col("montant_ht").sum().alias("turpe_fixe_f15")
    ])

    # Jointure avec le calcul√© (inner = uniquement PDL pr√©sents des deux c√¥t√©s)
    _df_comparison_final = df_f15_final_par_pdl.join(
        df_turpe_fixe_pdl,
        on="pdl",
        how="inner"
    )

    montant_f15_avec_calcul = _df_comparison_final.select(pl.col("turpe_fixe_f15").sum()).item()
    montant_calcule_final = _df_comparison_final.select(pl.col("turpe_fixe_total").sum()).item()
    nb_pdl_avec_calcul = len(_df_comparison_final)
    ecart_pdl_sans_calcul = _montant_f15_perimetre - montant_f15_avec_calcul

    # √âcart r√©siduel = vraie erreur de calcul
    ecart_residuel = montant_calcule_final - montant_f15_avec_calcul

    # Affichage en cascade
    print(f"\nüéØ √âTAPE 1 - Montant F15 fixe global:")
    print(f"   üí∞ {montant_f15_global:,.2f} ‚Ç¨ sur {nb_pdl_f15_global} PDL")

    print(f"\nüéØ √âTAPE 2 - Filtrage segment C5:")
    print(f"   üí∞ Montant C5: {montant_f15_c5:,.2f} ‚Ç¨ ({nb_pdl_c5} PDL)")
    print(f"   ‚ùå √âcart hors C5: {ecart_hors_c5:,.2f} ‚Ç¨ ({ecart_hors_c5/montant_f15_global*100:.1f}%)")

    print(f"\nüéØ √âTAPE 3 - Filtrage temporel (‚â§ {_date_coupure}):")
    print(f"   üí∞ Montant hors √† √©choir: {montant_f15_c5_temporel:,.2f} ‚Ç¨ ({nb_pdl_c5_temporel} PDL)")
    print(f"   ‚ùå √âcart facturation √† √©choir: {ecart_a_echoir:,.2f} ‚Ç¨ ({ecart_a_echoir/montant_f15_global*100:.1f}%)")

    if len(df_pdl_odoo) > 0:
        print(f"\nüéØ √âTAPE 4 - Filtrage p√©rim√®tre EDN:")
        print(f"   üí∞ Montant p√©rim√®tre: {_montant_f15_perimetre:,.2f} ‚Ç¨ ({_nb_pdl_perimetre} PDL)")
        print(f"   ‚ùå √âcart hors p√©rim√®tre: {ecart_hors_perimetre:,.2f} ‚Ç¨ ({ecart_hors_perimetre/montant_f15_global*100:.1f}%)")

    print(f"\nüéØ √âTAPE 5 - PDL avec calcul disponible:")
    print(f"   üí∞ Montant F15 (PDL avec calcul): {montant_f15_avec_calcul:,.2f} ‚Ç¨ ({nb_pdl_avec_calcul} PDL)")
    print(f"   üí∞ Montant calcul√©: {montant_calcule_final:,.2f} ‚Ç¨")
    print(f"   ‚ùå √âcart PDL sans C15: {ecart_pdl_sans_calcul:,.2f} ‚Ç¨ ({ecart_pdl_sans_calcul/montant_f15_global*100:.1f}%)")

    print(f"\nüéØ √âTAPE 6 - √âCART R√âSIDUEL (vraie erreur):")
    print(f"   ‚ö†Ô∏è √âcart de calcul: {ecart_residuel:+,.2f} ‚Ç¨ ({ecart_residuel/montant_f15_global*100:+.1f}%)")

    # R√©sum√© des attributions
    total_ecart_brut = montant_calcule_final - montant_f15_global
    print(f"\nüìà ATTRIBUTION DES √âCARTS:")
    print(f"   √âcart total brut: {total_ecart_brut:+,.2f} ‚Ç¨ (100%)")

    if total_ecart_brut != 0:
        print(f"   ‚Ä¢ Hors C5: {-ecart_hors_c5:,.2f} ‚Ç¨ ({-ecart_hors_c5/abs(total_ecart_brut)*100:.1f}%)")
        print(f"   ‚Ä¢ Facturation √† √©choir: {-ecart_a_echoir:,.2f} ‚Ç¨ ({-ecart_a_echoir/abs(total_ecart_brut)*100:.1f}%)")
        if len(df_pdl_odoo) > 0:
            print(f"   ‚Ä¢ Hors p√©rim√®tre: {-ecart_hors_perimetre:,.2f} ‚Ç¨ ({-ecart_hors_perimetre/abs(total_ecart_brut)*100:.1f}%)")
        print(f"   ‚Ä¢ PDL sans C15: {-ecart_pdl_sans_calcul:,.2f} ‚Ç¨ ({-ecart_pdl_sans_calcul/abs(total_ecart_brut)*100:.1f}%)")
        print(f"   ‚Ä¢ Erreur de calcul: {ecart_residuel:,.2f} ‚Ç¨ ({ecart_residuel/abs(total_ecart_brut)*100:.1f}%)")

    df_comparison_final_entonnoir = _df_comparison_final
    return df_comparison_final_entonnoir


@app.cell(hide_code=True)
def turpe_fixe_quality_metrics(df_comparison_fixe, ecart_global_fixe, total_f15_fixe):
    """M√©triques de qualit√© pour le TURPE fixe"""

    # Calculs sur PDL communs uniquement
    df_communs = df_comparison_fixe.filter(pl.col("statut_pdl") == "Pr√©sent des 2 c√¥t√©s")

    if len(df_communs) == 0:
        print("‚ö†Ô∏è Aucun PDL commun trouv√©!")
        df_quality_result = None
    else:
        # M√©triques de pr√©cision
        nb_precise_1eur = df_communs.filter(pl.col("ecart_absolu").abs() <= 1.0).select(pl.len()).item()
        nb_precise_5pct = df_communs.filter(pl.col("ecart_relatif_pct").abs() <= 5.0).select(pl.len()).item()
        nb_total_communs = len(df_communs)

        precision_1eur = (nb_precise_1eur / nb_total_communs) * 100
        precision_5pct = (nb_precise_5pct / nb_total_communs) * 100

        ecart_moyen = df_communs.select(pl.col("ecart_absolu").mean()).item()
        ecart_median = df_communs.select(pl.col("ecart_absolu").median()).item()

        # √âvaluation qualitative
        _ecart_global_pct = abs(ecart_global_fixe / total_f15_fixe) * 100 if total_f15_fixe > 0 else 0

        if _ecart_global_pct < 1.0 and precision_5pct > 95:
            _evaluation = "üü¢ EXCELLENTE"
            _recommandation = "TURPE fixe tr√®s fiable"
        elif _ecart_global_pct < 2.0 and precision_5pct > 90:
            _evaluation = "üü° BONNE"
            _recommandation = "Quelques ajustements mineurs"
        elif _ecart_global_pct < 5.0:
            _evaluation = "üü† CORRECTE"
            _recommandation = "R√©vision des r√®gles tarifaires recommand√©e"
        else:
            _evaluation = "üî¥ √Ä AM√âLIORER"
            _recommandation = "Probl√®mes majeurs dans le calcul"

        print(f"\nüéØ M√âTRIQUES DE QUALIT√â TURPE FIXE:")
        print(f"   üìä Pr√©cision ¬±1‚Ç¨: {precision_1eur:.1f}% ({nb_precise_1eur}/{nb_total_communs} PDL)")
        print(f"   üìä Pr√©cision ¬±5%: {precision_5pct:.1f}% ({nb_precise_5pct}/{nb_total_communs} PDL)")
        print(f"   üìä √âcart moyen: {ecart_moyen:+.2f} ‚Ç¨ | √âcart m√©dian: {ecart_median:+.2f} ‚Ç¨")
        print(f"   üéØ √âvaluation: {_evaluation}")
        print(f"   üí° Recommandation: {_recommandation}")

        df_quality_result = {
            'evaluation': _evaluation,
            'precision_1eur': precision_1eur,
            'precision_5pct': precision_5pct,
            'ecart_moyen': ecart_moyen,
            'recommandation': _recommandation
        }

    df_quality_result


@app.cell
def _():
    mo.md(r"""## Entonnoir d'attribution des √©carts - TURPE Fixe""")
    return


@app.cell
def run_funnel_analysis_turpe_fixe(df_f15_turpe, df_turpe_fixe_pdl, df_pdl_odoo):
    """Ex√©cution de l'analyse en entonnoir pour le TURPE fixe"""
    df_entonnoir_result = funnel_analysis_turpe_fixe(df_f15_turpe, df_turpe_fixe_pdl, df_pdl_odoo)
    return (df_entonnoir_result,)


@app.cell
def _():
    mo.md(r"""# Analyse fiabilit√© calcul turpe variable""")
    return


@app.cell
def _():
    mo.md(r"""## Calcul turpe Variable""")
    return


@app.cell(hide_code=True)
def calculate_turpe_variable(df_historique, df_releves):
    """Calcul TURPE variable uniquement (√©nergies)"""

    mo.md("## ‚ö° Calcul TURPE Variable (√ânergies)")

    print("üîÑ Calcul des p√©riodes d'√©nergie...")
    _start_time_variable = time.time()

    # Pipeline √©nergie complet (inclut chronologie + calcul + TURPE variable)
    lf_periodes_energie = pipeline_energie_polars(
        pl.LazyFrame(df_historique),
        pl.LazyFrame(df_releves)
    )
    df_periodes_energie = lf_periodes_energie.collect()

    # Agr√©gation du TURPE variable par PDL
    df_turpe_variable_pdl = (
        df_periodes_energie
        .group_by("pdl")
        .agg([
            pl.col("turpe_variable").sum().alias("turpe_variable_total")
        ])
    )

    calc_time_variable = time.time() - _start_time_variable

    # Statistiques TURPE variable
    total_turpe_variable = df_turpe_variable_pdl.select(pl.col("turpe_variable_total").sum()).item()
    nb_pdl_variable = df_turpe_variable_pdl.select(pl.col("pdl").n_unique()).item()

    print(f"‚úÖ Pipeline TURPE variable ex√©cut√© en {calc_time_variable:.1f}s")
    print(f"üí∞ Montant total TURPE variable calcul√©: {total_turpe_variable:,.2f} ‚Ç¨")
    print(f"üè† {nb_pdl_variable} PDL trait√©s (avec donn√©es R151)")
    return (df_turpe_variable_pdl,)


@app.cell
def funnel_analysis_variable(
    df_f15_variable,
    df_pdl_odoo,
    df_turpe_variable_pdl,
):
    """Analyse en entonnoir des √©carts TURPE variable"""

    mo.md("## üìä Analyse en entonnoir - TURPE Variable")

    montant_f15_variable_global = df_f15_variable.select(pl.col("montant_ht").sum()).item()
    nb_pdl_f15_variable = df_f15_variable.select(pl.col("pdl").n_unique()).item()

    print(f"üéØ √âTAPE 1 - Montant F15 variable global:")
    print(f"   üí∞ {montant_f15_variable_global:,.2f} ‚Ç¨ sur {nb_pdl_f15_variable} PDL")

    # √âtape 2: R√©duction aux PDL avec donn√©es R151
    # D'abord agr√©g√©r F15 par PDL, puis joindre avec calcul√©
    df_f15_variable_par_pdl = (
        df_f15_variable
        .group_by("pdl")
        .agg([pl.col("montant_ht").sum().alias("turpe_variable_f15")])
    )

    df_variable_avec_r151 = (
        df_f15_variable_par_pdl
        .join(df_turpe_variable_pdl, on="pdl", how="inner")
        .with_columns([
            (pl.col("turpe_variable_total") - pl.col("turpe_variable_f15")).alias("ecart_variable")
        ])
    )

    montant_f15_variable_r151 = df_variable_avec_r151.select(pl.col("turpe_variable_f15").sum()).item()
    montant_calcule_variable_r151 = df_variable_avec_r151.select(pl.col("turpe_variable_total").sum()).item()
    nb_pdl_avec_r151 = len(df_variable_avec_r151)

    ecart_pdl_sans_r151_eur = montant_f15_variable_global - montant_f15_variable_r151
    ecart_pdl_sans_r151_pct = (ecart_pdl_sans_r151_eur / montant_f15_variable_global) * 100

    print(f"üéØ √âTAPE 2 - R√©duction aux PDL avec donn√©es R151:")
    print(f"   üìä {nb_pdl_avec_r151} PDL avec R151 (sur {nb_pdl_f15_variable} total)")
    print(f"   üí∞ F15 variable (R151): {montant_f15_variable_r151:,.2f} ‚Ç¨")
    print(f"   üí∞ Calcul√© variable (R151): {montant_calcule_variable_r151:,.2f} ‚Ç¨")
    print(f"   ‚ùå √âcart PDL sans R151: {ecart_pdl_sans_r151_eur:,.2f} ‚Ç¨ ({ecart_pdl_sans_r151_pct:.1f}%)")

    # √âtape 3: R√©duction aux PDL du p√©rim√®tre (si donn√©es Odoo disponibles)
    if len(df_pdl_odoo) > 0:
        df_variable_perimetre = (
            df_variable_avec_r151
            .join(df_pdl_odoo.select("pdl"), on="pdl", how="inner")
        )

        nb_pdl_perimetre = len(df_variable_perimetre)
        montant_f15_perimetre = df_variable_perimetre.select(pl.col("turpe_variable_f15").sum()).item()
        montant_calcule_perimetre = df_variable_perimetre.select(pl.col("turpe_variable_total").sum()).item()

        ecart_hors_perimetre_eur = montant_f15_variable_r151 - montant_f15_perimetre
        ecart_hors_perimetre_pct = (ecart_hors_perimetre_eur / montant_f15_variable_global) * 100

        print(f"üéØ √âTAPE 3 - R√©duction au p√©rim√®tre Odoo:")
        print(f"   üè¢ {nb_pdl_perimetre} PDL dans le p√©rim√®tre (sur {nb_pdl_avec_r151} avec R151)")
        print(f"   üí∞ F15 p√©rim√®tre: {montant_f15_perimetre:,.2f} ‚Ç¨")
        print(f"   üí∞ Calcul√© p√©rim√®tre: {montant_calcule_perimetre:,.2f} ‚Ç¨")
        print(f"   ‚ùå √âcart PDL hors p√©rim√®tre: {ecart_hors_perimetre_eur:,.2f} ‚Ç¨ ({ecart_hors_perimetre_pct:.1f}%)")

        # √âcart r√©siduel = erreur "vraie"
        ecart_residuel_eur = montant_calcule_perimetre - montant_f15_perimetre
        ecart_residuel_pct = (abs(ecart_residuel_eur) / montant_f15_variable_global) * 100

        print(f"üéØ √âTAPE 4 - √âcart r√©siduel (erreur vraie):")
        print(f"   ‚ö†Ô∏è √âcart de calcul: {ecart_residuel_eur:+,.2f} ‚Ç¨ ({ecart_residuel_pct:.1f}%)")

        funnel_results = {
            'montant_f15_global': montant_f15_variable_global,
            'ecart_sans_r151': ecart_pdl_sans_r151_eur,
            'ecart_hors_perimetre': ecart_hors_perimetre_eur,
            'ecart_residuel': ecart_residuel_eur,
            'nb_pdl_f15': nb_pdl_f15_variable,
            'nb_pdl_r151': nb_pdl_avec_r151,
            'nb_pdl_perimetre': nb_pdl_perimetre
        }
    else:
        # Sans donn√©es Odoo, √©cart r√©siduel = diff√©rence de calcul sur PDL avec R151
        ecart_residuel_eur = montant_calcule_variable_r151 - montant_f15_variable_r151
        ecart_residuel_pct = (abs(ecart_residuel_eur) / montant_f15_variable_global) * 100

        print(f"üéØ √âTAPE 3 - √âcart r√©siduel (sans filtre p√©rim√®tre):")
        print(f"   ‚ö†Ô∏è √âcart de calcul: {ecart_residuel_eur:+,.2f} ‚Ç¨ ({ecart_residuel_pct:.1f}%)")

        funnel_results = {
            'montant_f15_global': montant_f15_variable_global,
            'ecart_sans_r151': ecart_pdl_sans_r151_eur,
            'ecart_hors_perimetre': 0,
            'ecart_residuel': ecart_residuel_eur,
            'nb_pdl_f15': nb_pdl_f15_variable,
            'nb_pdl_r151': nb_pdl_avec_r151,
            'nb_pdl_perimetre': nb_pdl_avec_r151
        }
    return


@app.cell
def decomposition_summary(funnel_fixe, funnel_variable):
    """Synth√®se de la d√©composition des √©carts"""

    mo.md("## üìã Synth√®se de la d√©composition des √©carts")

    # Calcul des pourcentages
    montant_global = funnel_variable['montant_f15_global'] + funnel_fixe['montant_f15_fixe']

    pct_sans_r151 = (abs(funnel_variable['ecart_sans_r151']) / montant_global) * 100
    pct_hors_perimetre = (abs(funnel_variable['ecart_hors_perimetre']) / montant_global) * 100
    pct_erreur_variable = (abs(funnel_variable['ecart_residuel']) / montant_global) * 100
    pct_erreur_fixe = (abs(funnel_fixe['ecart_fixe']) / montant_global) * 100

    # Tableau de d√©composition
    decomposition = pl.DataFrame({
        "Composante": [
            "üí∞ Montant F15 total",
            "üìä PDL sans donn√©es R151",
            "üè¢ PDL hors p√©rim√®tre",
            "‚ö†Ô∏è Erreur calcul variable",
            "‚ö†Ô∏è Erreur calcul fixe",
            "‚úÖ Total √©carts expliqu√©s"
        ],
        "Montant (‚Ç¨)": [
            f"{montant_global:,.2f}",
            f"{funnel_variable['ecart_sans_r151']:+,.2f}",
            f"{funnel_variable['ecart_hors_perimetre']:+,.2f}",
            f"{funnel_variable['ecart_residuel']:+,.2f}",
            f"{funnel_fixe['ecart_fixe']:+,.2f}",
            f"{funnel_variable['ecart_sans_r151'] + funnel_variable['ecart_hors_perimetre'] + funnel_variable['ecart_residuel'] + funnel_fixe['ecart_fixe']:+,.2f}"
        ],
        "% du total": [
            "100.0%",
            f"{pct_sans_r151:.1f}%",
            f"{pct_hors_perimetre:.1f}%",
            f"{pct_erreur_variable:.1f}%",
            f"{pct_erreur_fixe:.1f}%",
            f"{pct_sans_r151 + pct_hors_perimetre + pct_erreur_variable + pct_erreur_fixe:.1f}%"
        ],
        "Type": [
            "R√©f√©rence",
            "Attendu (pas de donn√©es)",
            "Attendu (hors scope)",
            "√Ä corriger",
            "√Ä corriger",
            "Total"
        ]
    })

    print("üìä D√âCOMPOSITION DES √âCARTS TURPE:")
    print(decomposition.to_pandas().to_string(index=False))

    # √âvaluation qualitative
    erreur_totale_pct = pct_erreur_variable + pct_erreur_fixe

    if erreur_totale_pct < 2:
        _evaluation = "üü¢ EXCELLENTE"
        _recommandation = "Validation tr√®s satisfaisante"
    elif erreur_totale_pct < 5:
        _evaluation = "üü° BONNE"
        _recommandation = "Quelques √©carts mineurs √† analyser"
    elif erreur_totale_pct < 10:
        _evaluation = "üü† CORRECTE"
        _recommandation = "Ajustements n√©cessaires"
    else:
        _evaluation = "üî¥ √Ä AM√âLIORER"
        _recommandation = "R√©vision du pipeline requise"

    print(f"\nüéØ √âVALUATION: {_evaluation}")
    print(f"   Erreur totale de calcul: {erreur_totale_pct:.1f}%")
    print(f"   Recommandation: {_recommandation}")
    return


@app.cell
def temporal_alignment_analysis(df_f15_turpe):
    """Analyse des d√©calages temporels (premiers/derniers mois)"""

    mo.md("## üìÖ Gestion des d√©calages temporels")

    # Identifier les p√©riodes partielles (premiers/derniers mois)
    # Crit√®re : p√©riode < 25 jours (approximation pour mois partiel)
    df_f15_with_duration = (
        df_f15_turpe
        .with_columns([
            pl.col("date_debut").str.to_datetime().alias("debut_dt"),
            pl.col("date_fin").str.to_datetime().alias("fin_dt")
        ])
        .with_columns([
            (pl.col("fin_dt") - pl.col("debut_dt")).dt.total_days().alias("duree_jours")
        ])
        .with_columns([
            pl.when(pl.col("duree_jours") < 25)
            .then(pl.lit("Partiel"))
            .otherwise(pl.lit("Complet"))
            .alias("type_periode")
        ])
    )

    # Statistiques sur les p√©riodes partielles
    montant_total = df_f15_with_duration.select(pl.col("montant_ht").sum()).item()
    montant_partiel = (
        df_f15_with_duration
        .filter(pl.col("type_periode") == "Partiel")
        .select(pl.col("montant_ht").sum())
        .item()
    )

    nb_lignes_partielles = (
        df_f15_with_duration
        .filter(pl.col("type_periode") == "Partiel")
        .select(pl.len())
        .item()
    )

    nb_pdl_avec_partiels = (
        df_f15_with_duration
        .filter(pl.col("type_periode") == "Partiel")
        .select(pl.col("pdl").n_unique())
        .item()
    )

    impact_temporel_pct = (montant_partiel / montant_total) * 100 if montant_total > 0 else 0

    print(f"üéØ IMPACT DES D√âCALAGES TEMPORELS:")
    print(f"   üìä {nb_lignes_partielles} lignes de facturation partielles")
    print(f"   üè† {nb_pdl_avec_partiels} PDL concern√©s par des mois partiels")
    print(f"   üí∞ Montant p√©riodes partielles: {montant_partiel:,.2f} ‚Ç¨ ({impact_temporel_pct:.1f}% du total)")
    print(f"   ‚ö†Ô∏è Impact temporel estim√© sur la comparaison: ~{impact_temporel_pct:.1f}%")

    # Recommandation
    if impact_temporel_pct > 5:
        print(f"   üîß Recommandation: Exclure les p√©riodes partielles de la validation")
    else:
        print(f"   ‚úÖ Impact temporel faible, peut √™tre ignor√© dans la validation")

    # Donn√©es nettoy√©es (mois complets uniquement)
    df_f15_mois_complets = (
        df_f15_with_duration
        .filter(pl.col("type_periode") == "Complet")
    )

    montant_mois_complets = df_f15_mois_complets.select(pl.col("montant_ht").sum()).item()
    nb_pdl_mois_complets = df_f15_mois_complets.select(pl.col("pdl").n_unique()).item()

    print(f"   üìã Donn√©es mois complets: {montant_mois_complets:,.2f} ‚Ç¨ sur {nb_pdl_mois_complets} PDL")
    return


@app.cell
def validation_conclusion(temporal_analysis):
    """Conclusion de la validation TURPE avec recommandations"""

    mo.md("## üéØ Conclusion et recommandations")

    print("üìã SYNTH√àSE DE LA VALIDATION TURPE F15:")
    print(f"   ‚úÖ Analyse structur√©e en entonnoir r√©alis√©e")
    print(f"   üìä S√©paration TURPE fixe/variable effectu√©e")
    print(f"   üè¢ Filtrage p√©rim√®tre Odoo appliqu√©")
    print(f"   üìÖ D√©calages temporels quantifi√©s ({temporal_analysis['impact_temporel_pct']:.1f}% du total)")

    print(f"\nüéØ APPROCHE M√âTHODOLOGIQUE:")
    print(f"   1Ô∏è‚É£ Attribution des √©carts par cause identifi√©e")
    print(f"   2Ô∏è‚É£ Distinction erreurs attendues vs inattendues")
    print(f"   3Ô∏è‚É£ Quantification pr√©cise de chaque source d'√©cart")
    print(f"   4Ô∏è‚É£ Focus sur les vrais probl√®mes de calcul")

    print(f"\nüìà PROCHAINES √âTAPES:")
    print(f"   üîß Utiliser ce notebook r√©guli√®rement pour valider le pipeline")
    print(f"   üìä Ajuster les seuils selon vos crit√®res m√©tier")
    print(f"   ‚öôÔ∏è Int√©grer dans le processus CI/CD si souhait√©")
    print(f"   üìà √âtendre l'analyse √† d'autres segments que C5 si pertinent")

    print(f"\nüí° AVANTAGES DE CETTE APPROCHE:")
    print(f"   ‚úÖ Erreurs attendues vs inattendues clairement s√©par√©es")
    print(f"   ‚úÖ Quantification pr√©cise de chaque source d'√©cart")
    print(f"   ‚úÖ Focus sur les vrais probl√®mes n√©cessitant correction")
    print(f"   ‚úÖ Validation objective et reproductible")
    return


if __name__ == "__main__":
    app.run()
